PEP: 015  
Title: OpenShift 3 Git Hosting  
Status: draft  
Author: Andy Goldstein <agoldste@redhat.com>  
Arch Priority: medium  
Complexity: 40  
Affected Components: apiserver  
Affected Teams: Runtime, Infrastructure  
User Impact: low  
Epic: [SCM](https://trello.com/c/L1Df40pk/68-source-control-management-scm)

Abstract
--------
Create a hosted Git service for OpenShift 3.

Motivation
----------
The OpenShift hosted Git service provides Git repositories for users who don't have access to any other Git repository hosting service. 

Specification
-------------
### OpenShift 2 model
- Each application gets its own Git repository.
- The Git repository lives in the head gear.
- The Git repository’s URL is the same for all users with access to it; e.g. `ssh://537a84be4782ecb16e00062e@someapp-somedomain.rhcloud.com/~/git/someapp.git/`.
- Pushing to an app's Git repository triggers a build by default. If the build succeeds, it becomes the active deployment.
- If the head gear “dies” (filesystem corruption, node lost w/o a backup, etc), you can’t `git push` any more…; however:
- The Git repository is synchronized to every haproxy gear (if the app is HA), but:
	- The broker doesn’t support a secondary haproxy gear becoming the new head gear.

### OpenShift 3 proposed model
- A Git repository belongs to a project.
- A project can have multiple Git repositories.
- All Git repositories are stored in Git backend pods.
- Git Backend Pods are multi-tenant; that is, a single backend may host repositories from different projects

### Accessing a Git repository
Clients won't connect to a Git backend directly. Instead, clients connect to an HTTPS proxy, and the proxy is responsible for:

1. authenticating the client
2. ensuring they're authorized to access the repository
3. determining on which Git backend the repository lives
4. forwarding the request to the Git backend

### HTTPS proxy authentication
The HTTPS proxy delegates authentication to the OpenShift master server. The client may supply a token (as a password) or a client certificate.

For token authentication, the token uniquely identifies the client and must be considered secret and equivalent to a password. 

For client certificate authentication, the certificate also uniquely identifies the client. 

Clients may be real users or service accounts. Tokens and client certificates may be revoked and regenerated by project administrators.

### Git repostiory authorization
After the proxy authenticates the client, it verifies the client is authorized to access the Git repository by querying the OpenShift master. If authorization succeeds, the proxy determines the internal URL of the Git backend (again, by asking the OpenShift master). It then forwards the request to the Git backend.

### Git backend pod
The Git backend pod runs a container capable of handling Git requests using Git's "smart HTTP" protocol. When it receives a requested forward from the proxy, it first repeats the same authentication and authorization checks as the proxy. This may be achieved via a container acting as a proxy inside the Git backend pod, or in the same container that handles the smart HTTP requests.

### Git repository provisioning & management
A custom controller running in a Git backend pod watches the OpenShift master for new GitRepositories and creates a new Linux user and the appropriate directories and files for the new repository.

The controller could either run in the background in the same Git backend container that is running the smart HTTP server, or it could run in a separate container that is part of the same pod, as long as the appropriate files and directories are shared between the containers (`/etc/passwd` and the base directory for all the git repositories, e.g. `/var/lib/git`).

### Quotas
Each repository is assigned its own quota. Administrators should be able to configure the default quota value in the OpenShift master. Users may be able to request additional quota on a per repository basis.

### Recovery process
If a Git backend pod is lost unexpectedly, there must be a process to create a new pod to assume the duties of the previous one. The ideal way to handle this is to define a ReplicationController for the pod, and let OpenShift (Kubernetes) ensure the replica count is maintained at 1. If the pod dies, a replacement is created automatically as part of the replication controller functionality.

If the repository users are stored in `/etc/passwd`, this file must be bootstrapped appropriately.

The repositories themselves must be attached to the new Git backend container. This presumably will be handled as part of the replication controller replacement process. The repositories should be stored on a volume that can be detached from the lost pod and attached to the new one.

### Security considerations
With multiple repositories from different projects housed side by side in a Git backend, it is extremely important that a user only be able to access the repositories that he/she has access to.

Authentication and authorization checks are performed in both the HTTPS proxy and the Git backend.

Giving each Git user/repository (directory and descendent files) a unique MCS label and setting the execution context of each request appropriately can provide inter-repository isolation.

### SSH access
Accessing Git repositories via SSH can be accomplished with an SSH proxy that sits beside the HTTPS proxy. The SSH proxy handles URLs such as `<user>@git.openshift.com:<project>/<repo>`.

**NOTE**: we do not currently plan on implementing git+ssh for OpenShift 3. The ideas below demonstrate how it might be accomplished.

#### SSH authentication
A client may authenticate with the SSH proxy using any supported SSH authentication mechanism. As with HTTPS access, password authentication should use tokens instead of real passwords.

A custom NSS module delegates user lookups to OpenShift. OpenShift must be capable of returning all the appropriate information to the `getpwnam` method call.

For password/token authentication, the SSH proxy uses a custom PAM module to delegates authentication to OpenShift.

For public key authentication, the SSH proxy uses a custom AuthorizedKeysCommand to retrieve valid public keys from OpenShift.

A custom PAM module requests a user-specific token for the currently logged in `$USER` from the OpenShift master server. The module stores this token in an environment variable (`$USER_TOKEN`), which is used when communicating with the Git backend.

#### SSH proxy to Git backend
After the SSH proxy authenticates the client, it runs a command specified by `ForceCommand` that asks OpenShift which Git backend hosts the repository, then runs `docker exec` in the backend to run the original Git command, connecting the stdin/stdout/stderr streams back to the SSH proxy (and therefore back to the client).