PEP: 015  
Title: OpenShift 3 Git Hosting  
Status: draft  
Author: Andy Goldstein <agoldste@redhat.com>  
Arch Priority: medium  
Complexity: 40  
Affected Components: apiserver  
Affected Teams: Runtime, Infrastructure  
User Impact: low  
Epic: [SCM](https://trello.com/c/L1Df40pk/68-source-control-management-scm)

Abstract
--------
Create a hosted Git service for OpenShift 3.

Motivation
----------
The OpenShift hosted Git service provides Git repositories for users who don't have access to any other Git repository hosting service, or for someone who wants an all-in-one solution for source control with their PaaS. 

Specification
-------------
### OpenShift 2 model
- Each application gets its own Git repository.
- The Git repository lives in the head gear.
- The Git repository’s URL is the same for all users with access to it; e.g. `ssh://537a84be4782ecb16e00062e@someapp-somedomain.rhcloud.com/~/git/someapp.git/`.
- Pushing to an app's Git repository triggers a build by default. If the build succeeds, it becomes the active deployment.
- If the head gear “dies” (filesystem corruption, node lost w/o a backup, etc), you can’t `git push` any more…; however:
- The Git repository is synchronized to every haproxy gear (if the app is HA), but:
	- The broker doesn’t support a secondary haproxy gear becoming the new head gear.

### OpenShift 3 proposed model
- A Git repository belongs to a project.
- A project can have multiple Git repositories.
- All Git repositories are stored in Git backend pods.
- Git backend pods are multi-tenant; that is, a single backend may host repositories from different projects

### Model changes
Introduce a new object called **GitRepository** and the requisite modifications to make this a RESTful object that can be stored in etcd.

```go
type GitRepository struct {
		kapi.TypeMeta
		Labels         map[string]string
		GitBackendName  string
}
```

Introduce a new object called **GitBackend** and the requisite modifications to make this a RESTful object that can be stored in etcd.

```go
type GitBackend struct {
		kapi.TypeMeta
		Labels map[string]string
		RepositoryCount int
		RepositoryLimit int
		ReplicationControllerName string
}
```

### Repository backend assignment
When a repository is created, it must be assigned to a Git backend pod. A process watches for new GitRepositories and executes logic similar to the scheduler to find a fit for the new repository.

### Accessing a Git repository
Clients won't connect to a Git backend directly. Instead, clients connect to an HTTPS proxy, and the proxy is responsible for:

1. authenticating the client
2. ensuring they're authorized to access the repository
3. determining on which Git backend the repository lives
4. forwarding the request to the Git backend

### HTTPS proxy authentication
The HTTPS proxy delegates authentication to the OpenShift master server. The client may supply a token (as a password) or a client certificate.

For token authentication, the token uniquely identifies the client and must be considered secret and equivalent to a password. 

For client certificate authentication, the certificate also uniquely identifies the client. 

Clients may be real users or service accounts. Tokens and client certificates may be revoked and regenerated by project administrators.

### Git repository authorization
After the proxy authenticates the client, it verifies the client is authorized to access the Git repository by querying the OpenShift master. If authorization succeeds, OpenShift returns the internal URL of the Git backend pod where the repository lives. The proxy then forwards the request to the Git backend.

If token authentication is used, the token is in the `Authorization` header and must be passed to the Git backend so the backend may perform its own authentication and authorization checks.

If client certificate authentication is used, OpenShift returns a user-specific access token along with the Git backend pod's internal URL. The proxy adds the user-specific access token as the `Authorization` header and passes the request to the Git backend as described above.

### Git backend pod
The Git backend pod runs an OpenShift-provided container capable of handling Git requests using Git's "smart HTTP" protocol. When it receives a request forwarded from the proxy, it first authenticates and authorizes the token in the `Authorization` header. This may be achieved via a container acting as a proxy inside the Git backend pod, or in the same container that handles the smart HTTP requests.

### Per-request resource isolation and constraints
After the backend authenticates and authorizes the client, it forwards the request to a `git-http-backend` process to handle the Git request. This process must run in a constrained execution environment via cgroups. Doing so limits the CPU and memory resources and helps ensure that a single request can't overwhelm a backend's resources and hinder access to other clients and their requests.

With multiple repositories from different projects housed side by side in a Git backend, it is extremely important that a user only be able to access the repositories that he/she has access to. Each Git user/repository (directory and descendent files) has its own unique MCS label. Each `git-http-backend` process must run in the same SELinux execution context as the repository being accessed. This ensures that a `git-http-backend` process can only see the repositories the client's access token is allowed to see.

**NOTE:** this implies that the backend proxy process needs to run in the root context, as that is required to change the execution context of the `git-http-backend` process.

### Git repository provisioning & management
A custom controller running in a Git backend pod watches the OpenShift master for new GitRepositories and creates a new Linux user and the appropriate directories and files for the new repository. The user IDs and group IDs assigned to the Linux users for each Git repository need not be unique across the entire PaaS. UID 1000 on Backend 1 represents a different repository from the same UID 1000 on Backend 2.

The controller is also responsible for bootstrapping `/etc/passwd` for a container that is assuming a previous backend's duties.

The controller could either run in the background in the same Git backend container that is running the smart HTTP server, or it could run in a separate container that is part of the same pod, as long as the appropriate files and directories are shared between the containers (`/etc/passwd` and the base directory for all the git repositories, e.g. `/var/lib/git`).

### Quotas
Each repository may be assigned its own quota. Administrators should be able to configure the default quota value in the OpenShift master. Users may be able to request additional quota on a per repository basis.

Enabling quotas is optional. Special care may be needed to handle quotas in different file systems appropriately.

### Hooks
Users should not be able to run arbitrary code in Git hooks in their repositories, as this is a security concern. Instead, users are allowed to configure and enable/disable hooks that OpenShift supports by modifying the GitRepository in OpenShift, and the controller running in the Git backend updates a repository's hook files appropriately.

Examples of hooks might include:

- triggering a build in OpenShift
- triggering a build in Jenkins or another CI system

When a hook executes and communicates with another service such as OpenShift or Jenkins, it likely needs credentials for authenticating with the service. A user must be able to store these credentials securely in OpenShift.

### Recovery process
If a Git backend pod is lost unexpectedly, there must be a process to create a new pod to assume the duties of the previous one. Defining each backend pod via a replication controller ensures backend pods remain available even after a failover.

The repositories themselves must be stored on an attached volume that is reattached when a failover occurs.

### SSH access
Accessing Git repositories via SSH can be accomplished with an SSH proxy that sits beside the HTTPS proxy. The SSH proxy handles URLs such as `<user>@git.openshift.com:<project>/<repo>`.

**NOTE**: git+ssh is not a primarly goal for this PEP. The ideas below demonstrate how it might be accomplished in the future.

#### SSH authentication
A client may authenticate with the SSH proxy using any supported SSH authentication mechanism. As with HTTPS access, password authentication should use tokens instead of real passwords.

A custom NSS module delegates user lookups to OpenShift. OpenShift must be capable of returning all the appropriate information to the `getpwnam` method call.

For password/token authentication, the SSH proxy uses a custom PAM module to delegates authentication to OpenShift.

For public key authentication, the SSH proxy uses a custom AuthorizedKeysCommand to retrieve valid public keys from OpenShift.

A custom PAM module requests a user-specific token for the currently logged in `$USER` from the OpenShift master server. The module stores this token in an environment variable (`$USER_TOKEN`), which is used when communicating with the Git backend.

#### SSH proxy to Git backend
After the SSH proxy authenticates the client, it runs a command specified by `ForceCommand` that asks OpenShift which Git backend hosts the repository, then runs `docker exec` in the backend to run the original Git command, connecting the stdin/stdout/stderr streams back to the SSH proxy (and therefore back to the client).
